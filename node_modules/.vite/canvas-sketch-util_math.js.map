{
  "version": 3,
  "sources": ["../defined/index.js", "../canvas-sketch-util/lib/wrap.js", "../canvas-sketch-util/math.js", "dep:canvas-sketch-util_math"],
  "sourcesContent": ["'use strict';\n\nmodule.exports = function defined() {\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tif (typeof arguments[i] !== 'undefined') {\n\t\t\treturn arguments[i];\n\t\t}\n\t}\n};\n", "module.exports = wrap;\nfunction wrap (value, from, to) {\n  if (typeof from !== 'number' || typeof to !== 'number') {\n    throw new TypeError('Must specify \"to\" and \"from\" arguments as numbers');\n  }\n  // algorithm from http://stackoverflow.com/a/5852628/599884\n  if (from > to) {\n    var t = from;\n    from = to;\n    to = t;\n  }\n  var cycle = to - from;\n  if (cycle === 0) {\n    return to;\n  }\n  return value - cycle * Math.floor((value - from) / cycle);\n}\n", "var defined = require('defined');\nvar wrap = require('./lib/wrap');\nvar EPSILON = Number.EPSILON;\n\nfunction clamp (value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value);\n}\n\nfunction clamp01 (v) {\n  return clamp(v, 0, 1);\n}\n\nfunction lerp (min, max, t) {\n  return min * (1 - t) + max * t;\n}\n\nfunction inverseLerp (min, max, t) {\n  if (Math.abs(min - max) < EPSILON) return 0;\n  else return (t - min) / (max - min);\n}\n\nfunction smoothstep (min, max, t) {\n  var x = clamp(inverseLerp(min, max, t), 0, 1);\n  return x * x * (3 - 2 * x);\n}\n\nfunction toFinite (n, defaultValue) {\n  defaultValue = defined(defaultValue, 0);\n  return typeof n === 'number' && isFinite(n) ? n : defaultValue;\n}\n\nfunction expandVector (dims) {\n  if (typeof dims !== 'number') throw new TypeError('Expected dims argument');\n  return function (p, defaultValue) {\n    defaultValue = defined(defaultValue, 0);\n    var scalar;\n    if (p == null) {\n      // No vector, create a default one\n      scalar = defaultValue;\n    } else if (typeof p === 'number' && isFinite(p)) {\n      // Expand single channel to multiple vector\n      scalar = p;\n    }\n\n    var out = [];\n    var i;\n    if (scalar == null) {\n      for (i = 0; i < dims; i++) {\n        out[i] = toFinite(p[i], defaultValue);\n      }\n    } else {\n      for (i = 0; i < dims; i++) {\n        out[i] = scalar;\n      }\n    }\n    return out;\n  };\n}\n\nfunction lerpArray (min, max, t, out) {\n  out = out || [];\n  if (min.length !== max.length) {\n    throw new TypeError('min and max array are expected to have the same length');\n  }\n  for (var i = 0; i < min.length; i++) {\n    out[i] = lerp(min[i], max[i], t);\n  }\n  return out;\n}\n\nfunction newArray (n, initialValue) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  var out = [];\n  for (var i = 0; i < n; i++) out.push(initialValue);\n  return out;\n}\n\nfunction linspace (n, opts) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  opts = opts || {};\n  if (typeof opts === 'boolean') {\n    opts = { endpoint: true };\n  }\n  var offset = defined(opts.offset, 0);\n  if (opts.endpoint) {\n    return newArray(n).map(function (_, i) {\n      return n <= 1 ? 0 : ((i + offset) / (n - 1));\n    });\n  } else {\n    return newArray(n).map(function (_, i) {\n      return (i + offset) / n;\n    });\n  }\n}\n\nfunction lerpFrames (values, t, out) {\n  t = clamp(t, 0, 1);\n\n  var len = values.length - 1;\n  var whole = t * len;\n  var frame = Math.floor(whole);\n  var fract = whole - frame;\n\n  var nextFrame = Math.min(frame + 1, len);\n  var a = values[frame % values.length];\n  var b = values[nextFrame % values.length];\n  if (typeof a === 'number' && typeof b === 'number') {\n    return lerp(a, b, fract);\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return lerpArray(a, b, fract, out);\n  } else {\n    throw new TypeError('Mismatch in value type of two array elements: ' + frame + ' and ' + nextFrame);\n  }\n}\n\nfunction mod (a, b) {\n  return ((a % b) + b) % b;\n}\n\nfunction degToRad (n) {\n  return n * Math.PI / 180;\n}\n\nfunction radToDeg (n) {\n  return n * 180 / Math.PI;\n}\n\nfunction fract (n) {\n  return n - Math.floor(n);\n}\n\nfunction sign (n) {\n  if (n > 0) return 1;\n  else if (n < 0) return -1;\n  else return 0;\n}\n\n// Specific function from Unity / ofMath, not sure its needed?\n// function lerpWrap (a, b, t, min, max) {\n//   return wrap(a + wrap(b - a, min, max) * t, min, max)\n// }\n\nfunction pingPong (t, length) {\n  t = mod(t, length * 2);\n  return length - Math.abs(t - length);\n}\n\nfunction damp (a, b, lambda, dt) {\n  return lerp(a, b, 1 - Math.exp(-lambda * dt));\n}\n\nfunction dampArray (a, b, lambda, dt, out) {\n  out = out || [];\n  for (var i = 0; i < a.length; i++) {\n    out[i] = damp(a[i], b[i], lambda, dt);\n  }\n  return out;\n}\n\nfunction mapRange (value, inputMin, inputMax, outputMin, outputMax, clamp) {\n  // Reference:\n  // https://openframeworks.cc/documentation/math/ofMath/\n  if (Math.abs(inputMin - inputMax) < EPSILON) {\n    return outputMin;\n  } else {\n    var outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);\n    if (clamp) {\n      if (outputMax < outputMin) {\n        if (outVal < outputMax) outVal = outputMax;\n        else if (outVal > outputMin) outVal = outputMin;\n      } else {\n        if (outVal > outputMax) outVal = outputMax;\n        else if (outVal < outputMin) outVal = outputMin;\n      }\n    }\n    return outVal;\n  }\n}\n\nmodule.exports = {\n  mod: mod,\n  fract: fract,\n  sign: sign,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  wrap: wrap,\n  pingPong: pingPong,\n  linspace: linspace,\n  lerp: lerp,\n  lerpArray: lerpArray,\n  inverseLerp: inverseLerp,\n  lerpFrames: lerpFrames,\n  clamp: clamp,\n  clamp01: clamp01,\n  smoothstep: smoothstep,\n  damp: damp,\n  dampArray: dampArray,\n  mapRange: mapRange,\n  expand2D: expandVector(2),\n  expand3D: expandVector(3),\n  expand4D: expandVector(4)\n};\n", "export default require(\"./node_modules/canvas-sketch-util/math.js\");"],
  "mappings": "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",
  "names": []
}
